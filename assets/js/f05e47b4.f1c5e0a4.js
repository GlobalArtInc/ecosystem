"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[246],{2592(e,n,o){o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"packages/nestjs-typeorm-outbox","title":"@globalart/nestjs-typeorm-outbox","description":"NestJS module for implementing the Outbox pattern with TypeORM. Provides reliable message delivery to Kafka through a transactional outbox table.","source":"@site/content/packages/nestjs-typeorm-outbox.mdx","sourceDirName":"packages","slug":"/packages/nestjs-typeorm-outbox","permalink":"/packages/nestjs-typeorm-outbox","draft":false,"unlisted":false,"editUrl":"https://github.com/GlobalArtInc/ecosystem/tree/main/docs/content/packages/nestjs-typeorm-outbox.mdx","tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"sidebar_position":8},"sidebar":"tutorialSidebar","previous":{"title":"@globalart/nestjs-temporal","permalink":"/packages/nestjs-temporal"},"next":{"title":"@globalart/zod-to-proto","permalink":"/packages/zod-to-proto"}}');var r=o(7900),s=o(3351);const i={sidebar_position:8},a="@globalart/nestjs-typeorm-outbox",l={},c=[{value:"Installation",id:"installation",level:2},{value:"Overview",id:"overview",level:2},{value:"Key Features",id:"key-features",level:2},{value:"Quick Start",id:"quick-start",level:2},{value:"Basic Setup",id:"basic-setup",level:3},{value:"Using the Service",id:"using-the-service",level:3},{value:"Configuration",id:"configuration",level:2},{value:"TypeormOutboxModule.forRoot",id:"typeormoutboxmoduleforroot",level:3},{value:"TypeormOutboxModule.forRootAsync",id:"typeormoutboxmoduleforrootasync",level:3},{value:"TypeormOutboxModule.registerCronAsync",id:"typeormoutboxmoduleregistercronasync",level:3},{value:"API Reference",id:"api-reference",level:2},{value:"TypeormOutboxService",id:"typeormoutboxservice",level:3},{value:"Methods",id:"methods",level:4},{value:"<code>create(options: CreateOutboxOptions): Promise&lt;void&gt;</code>",id:"createoptions-createoutboxoptions-promisevoid",level:5},{value:"TypeormOutboxEntity",id:"typeormoutboxentity",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Complete Example with Configuration",id:"complete-example-with-configuration",level:3},{value:"Using in a Controller",id:"using-in-a-controller",level:3},{value:"Using in a Transaction",id:"using-in-a-transaction",level:3},{value:"How It Works",id:"how-it-works",level:2},{value:"Transactional Outbox Pattern",id:"transactional-outbox-pattern",level:3},{value:"Message Structure in Kafka",id:"message-structure-in-kafka",level:3},{value:"Cron Job Configuration",id:"cron-job-configuration",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Requirements",id:"requirements",level:2},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Messages Not Being Sent",id:"messages-not-being-sent",level:3},{value:"Duplicate Messages",id:"duplicate-messages",level:3},{value:"Messages Accumulating in Table",id:"messages-accumulating-in-table",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"globalartnestjs-typeorm-outbox",children:"@globalart/nestjs-typeorm-outbox"})}),"\n",(0,r.jsx)(n.p,{children:"NestJS module for implementing the Outbox pattern with TypeORM. Provides reliable message delivery to Kafka through a transactional outbox table."}),"\n",(0,r.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",metastring:"npm2yarn",children:"npm install @globalart/nestjs-typeorm-outbox @nestjs/typeorm typeorm kafkajs\n"})}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"@globalart/nestjs-typeorm-outbox"})," module implements the Transactional Outbox pattern to ensure reliable message delivery to Kafka. Messages are saved to the database within the same transaction as business data, and then asynchronously sent to Kafka via a cron job."]}),"\n",(0,r.jsx)(n.h2,{id:"key-features",children:"Key Features"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Transactional Guarantee"})," - Messages are saved to the database within the same transaction"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Automatic Processing"})," - Cron job automatically sends messages to Kafka"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Database-Level Locking"})," - Uses PostgreSQL advisory locks to prevent duplicate processing"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Flexible Configuration"})," - Supports async configuration via ConfigService"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type Safety"})," - Full TypeScript support"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"quick-start",children:"Quick Start"}),"\n",(0,r.jsx)(n.h3,{id:"basic-setup",children:"Basic Setup"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { Module } from \"@nestjs/common\";\nimport { TypeOrmModule } from \"@nestjs/typeorm\";\nimport { TypeormOutboxModule, TypeormOutboxEntity } from \"@globalart/nestjs-typeorm-outbox\";\n\n@Module({\n  imports: [\n    TypeOrmModule.forRoot({\n      type: 'postgres',\n      host: 'localhost',\n      port: 5432,\n      username: 'postgres',\n      password: 'postgres',\n      database: 'postgres',\n      synchronize: true,\n      entities: [TypeormOutboxEntity],\n    }),\n    TypeormOutboxModule.forRoot({\n      typeOrmConnectionName: 'default',\n    }),\n    TypeormOutboxModule.registerCronAsync({\n      useFactory: (configService: ConfigService) => ({\n        kafkaConfig: {\n          transport: Transport.KAFKA,\n          options: {\n            client: {\n              clientId: 'kafka-client',\n              brokers: ['localhost:9092'],\n            },\n          },\n        },\n        typeOrmConnectionName: 'default',\n      }),\n      inject: [ConfigService],\n    }),\n  ],\n})\nexport class AppModule {}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"using-the-service",children:"Using the Service"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { Injectable } from \"@nestjs/common\";\nimport { \n  TypeormOutboxService, \n  InjectTypeormOutboxService \n} from \"@globalart/nestjs-typeorm-outbox\";\n\n@Injectable()\nexport class OrderService {\n  constructor(\n    @InjectTypeormOutboxService()\n    private readonly outboxService: TypeormOutboxService\n  ) {}\n\n  async createOrder(orderData: OrderData) {\n    return await this.dataSource.transaction(async (manager) => {\n      const order = await manager.save(Order, orderData);\n      \n      await this.outboxService.create({\n        destinationTopic: 'order.created',\n        payload: {\n          orderId: order.id,\n          userId: order.userId,\n          total: order.total,\n        },\n        headers: {\n          'event-type': 'order.created',\n          'version': '1.0',\n        },\n        keys: {\n          orderId: order.id,\n        },\n      });\n      \n      return order;\n    });\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,r.jsx)(n.h3,{id:"typeormoutboxmoduleforroot",children:"TypeormOutboxModule.forRoot"}),"\n",(0,r.jsx)(n.p,{children:"Registers the base module for working with outbox."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"TypeormOutboxModule.forRoot({\n  typeOrmConnectionName?: string; // TypeORM connection name (default: 'default')\n})\n"})}),"\n",(0,r.jsx)(n.h3,{id:"typeormoutboxmoduleforrootasync",children:"TypeormOutboxModule.forRootAsync"}),"\n",(0,r.jsx)(n.p,{children:"Async module registration."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"TypeormOutboxModule.forRootAsync({\n  imports?: Type[];\n  inject?: InjectionToken[];\n  useFactory?: (...args: any[]) => Promise<TypeormOutboxModuleOptions> | TypeormOutboxModuleOptions;\n})\n"})}),"\n",(0,r.jsx)(n.h3,{id:"typeormoutboxmoduleregistercronasync",children:"TypeormOutboxModule.registerCronAsync"}),"\n",(0,r.jsx)(n.p,{children:"Registers a cron job to process outbox messages."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"TypeormOutboxModule.registerCronAsync({\n  imports?: Type[];\n  inject?: any[];\n  useFactory?: (...args: any[]) => Promise<TypeormOutboxRegisterCronModuleOptions> | TypeormOutboxRegisterCronModuleOptions;\n})\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Configuration Parameters:"})}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Parameter"}),(0,r.jsx)(n.th,{children:"Type"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"typeOrmConnectionName"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"string"})}),(0,r.jsx)(n.td,{children:"TypeORM connection name (default: 'default')"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"kafkaConfig"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"KafkaOptions"})}),(0,r.jsx)(n.td,{children:"Kafka client configuration"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"api-reference",children:"API Reference"}),"\n",(0,r.jsx)(n.h3,{id:"typeormoutboxservice",children:"TypeormOutboxService"}),"\n",(0,r.jsx)(n.p,{children:"Service for creating outbox messages."}),"\n",(0,r.jsx)(n.h4,{id:"methods",children:"Methods"}),"\n",(0,r.jsx)(n.h5,{id:"createoptions-createoutboxoptions-promisevoid",children:(0,r.jsx)(n.code,{children:"create(options: CreateOutboxOptions): Promise<void>"})}),"\n",(0,r.jsx)(n.p,{children:"Creates a new outbox message."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface CreateOutboxOptions {\n  destinationTopic: string;        // Kafka topic for message delivery\n  payload: Record<string, unknown>; // Message payload\n  headers?: Record<string, string>; // Message headers (optional)\n  keys?: Record<string, unknown>;  // Keys for partitioning (optional)\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"await outboxService.create({\n  destinationTopic: 'user.created',\n  payload: {\n    userId: '123',\n    email: 'user@example.com',\n    name: 'John Doe',\n  },\n  headers: {\n    'event-type': 'user.created',\n    'version': '1.0',\n  },\n  keys: {\n    userId: '123',\n  },\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"typeormoutboxentity",children:"TypeormOutboxEntity"}),"\n",(0,r.jsx)(n.p,{children:"Entity for storing outbox messages."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'@Entity(\'outbox\')\nexport class TypeormOutboxEntity {\n  @PrimaryGeneratedColumn("uuid")\n  id!: string;\n\n  @CreateDateColumn({ name: \'created_at\' })\n  createdAt!: Date;\n\n  @UpdateDateColumn({ name: \'updated_at\' })\n  updatedAt!: Date;\n\n  @Column("character varying", { name: \'destination_topic\' })\n  destinationTopic!: string;\n\n  @Column("jsonb", { nullable: true })\n  headers!: Record<string, string>;\n\n  @Column("jsonb", { nullable: true })\n  keys!: Record<string, unknown>;\n\n  @Column("jsonb")\n  payload!: Record<string, unknown>;\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,r.jsx)(n.h3,{id:"complete-example-with-configuration",children:"Complete Example with Configuration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { Module } from \"@nestjs/common\";\nimport { TypeOrmModule } from \"@nestjs/typeorm\";\nimport { ConfigModule, ConfigService } from \"@nestjs/config\";\nimport { \n  TypeormOutboxModule, \n  TypeormOutboxEntity \n} from \"@globalart/nestjs-typeorm-outbox\";\nimport { KafkaOptions, Transport } from \"@nestjs/microservices\";\nimport { registerAs } from \"@nestjs/config\";\n\nconst kafkaConfig = registerAs('kafka', (): KafkaOptions => ({\n  transport: Transport.KAFKA,\n  options: {\n    client: {\n      clientId: 'kafka-client',\n      brokers: ['localhost:9092'],\n    },\n  },\n}));\n\n@Module({\n  imports: [\n    TypeOrmModule.forRoot({\n      type: 'postgres',\n      host: 'localhost',\n      port: 5432,\n      username: 'postgres',\n      password: 'postgres',\n      database: 'postgres',\n      synchronize: true,\n      entities: [TypeormOutboxEntity],\n    }),\n    ConfigModule.forRoot({\n      isGlobal: true,\n      load: [kafkaConfig],\n    }),\n    TypeormOutboxModule.forRoot({\n      typeOrmConnectionName: 'default',\n    }),\n    TypeormOutboxModule.registerCronAsync({\n      useFactory: (configService: ConfigService) => ({\n        kafkaConfig: configService.get<KafkaOptions>('kafka'),\n        typeOrmConnectionName: 'default',\n      }),\n      inject: [ConfigService],\n    }),\n  ],\n})\nexport class AppModule {}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"using-in-a-controller",children:"Using in a Controller"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { Controller, Post, Body } from \"@nestjs/common\";\nimport { \n  TypeormOutboxService, \n  InjectTypeormOutboxService \n} from \"@globalart/nestjs-typeorm-outbox\";\n\n@Controller('orders')\nexport class OrdersController {\n  constructor(\n    @InjectTypeormOutboxService()\n    private readonly outboxService: TypeormOutboxService\n  ) {}\n\n  @Post()\n  async createOrder(@Body() orderData: CreateOrderDto) {\n    const order = await this.orderService.create(orderData);\n    \n    await this.outboxService.create({\n      destinationTopic: 'order.created',\n      payload: {\n        orderId: order.id,\n        userId: order.userId,\n        total: order.total,\n        items: order.items,\n      },\n      headers: {\n        'event-type': 'order.created',\n        'version': '1.0',\n      },\n      keys: {\n        orderId: order.id,\n      },\n    });\n    \n    return order;\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"using-in-a-transaction",children:"Using in a Transaction"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { Injectable } from \"@nestjs/common\";\nimport { DataSource } from \"typeorm\";\nimport { \n  TypeormOutboxService, \n  InjectTypeormOutboxService \n} from \"@globalart/nestjs-typeorm-outbox\";\n\n@Injectable()\nexport class PaymentService {\n  constructor(\n    private readonly dataSource: DataSource,\n    @InjectTypeormOutboxService()\n    private readonly outboxService: TypeormOutboxService\n  ) {}\n\n  async processPayment(paymentData: PaymentData) {\n    return await this.dataSource.transaction(async (manager) => {\n      const payment = await manager.save(Payment, paymentData);\n      \n      await this.outboxService.create({\n        destinationTopic: 'payment.processed',\n        payload: {\n          paymentId: payment.id,\n          amount: payment.amount,\n          currency: payment.currency,\n          status: payment.status,\n        },\n        headers: {\n          'event-type': 'payment.processed',\n          'version': '1.0',\n        },\n        keys: {\n          paymentId: payment.id,\n        },\n      });\n      \n      return payment;\n    });\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"how-it-works",children:"How It Works"}),"\n",(0,r.jsx)(n.h3,{id:"transactional-outbox-pattern",children:"Transactional Outbox Pattern"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Message Creation"}),": When executing a business operation, a message is saved to the ",(0,r.jsx)(n.code,{children:"outbox"})," table within the same transaction"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cron Job Processing"}),": A cron job (every 10 seconds) retrieves unprocessed messages from the table"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Locking"}),": PostgreSQL advisory locks are used to prevent parallel processing by the same process"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Kafka Delivery"}),": Messages are sent to Kafka with the specified topic, keys, and headers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Deletion"}),": After successful delivery, the message is deleted from the table"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"message-structure-in-kafka",children:"Message Structure in Kafka"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"{\n  key: Record<string, unknown>;    // Keys for partitioning\n  value: Record<string, unknown>;  // Message payload\n  headers: Record<string, string>; // Message headers\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"cron-job-configuration",children:"Cron Job Configuration"}),"\n",(0,r.jsxs)(n.p,{children:["By default, the cron job runs every 10 seconds (",(0,r.jsx)(n.code,{children:"CronExpression.EVERY_10_SECONDS"}),"). This can be changed by overriding the controller:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { Controller } from "@nestjs/common";\nimport { Cron, CronExpression } from "@nestjs/schedule";\nimport { TypeormOutboxController } from "@globalart/nestjs-typeorm-outbox";\n\n@Controller()\nexport class CustomOutboxController extends TypeormOutboxController {\n  @Cron(CronExpression.EVERY_5_SECONDS)\n  async handleOutboxCron() {\n    await this.executeCronJob();\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use Transactions"}),": Always create outbox messages within the same transaction as business data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Specify Keys"}),": Use ",(0,r.jsx)(n.code,{children:"keys"})," to ensure proper partitioning in Kafka"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Add Headers"}),": Use ",(0,r.jsx)(n.code,{children:"headers"})," for event metadata (event type, version, etc.)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Monitoring"}),": Monitor the size of the ",(0,r.jsx)(n.code,{children:"outbox"})," table to detect processing issues"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Error Handling"}),": Ensure Kafka broker is available, otherwise messages will accumulate in the table"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"PostgreSQL (for advisory locks)"}),"\n",(0,r.jsx)(n.li,{children:"Kafka broker"}),"\n",(0,r.jsx)(n.li,{children:"NestJS application with configured TypeORM"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,r.jsx)(n.h3,{id:"messages-not-being-sent",children:"Messages Not Being Sent"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Check that Kafka broker is accessible and configuration is correct"}),"\n",(0,r.jsxs)(n.li,{children:["Ensure cron job is registered via ",(0,r.jsx)(n.code,{children:"registerCronAsync"})]}),"\n",(0,r.jsx)(n.li,{children:"Check logs for errors when sending messages"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"duplicate-messages",children:"Duplicate Messages"}),"\n",(0,r.jsx)(n.p,{children:"The module uses PostgreSQL advisory locks to prevent parallel processing. If you see duplicates:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Ensure PostgreSQL is being used"}),"\n",(0,r.jsx)(n.li,{children:"Check that multiple application instances are not running with the same lock ID"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"messages-accumulating-in-table",children:"Messages Accumulating in Table"}),"\n",(0,r.jsxs)(n.p,{children:["If messages are accumulating in the ",(0,r.jsx)(n.code,{children:"outbox"})," table:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Check Kafka broker availability"}),"\n",(0,r.jsx)(n.li,{children:"Check logs for errors"}),"\n",(0,r.jsx)(n.li,{children:"Ensure cron job is running (check startup logs)"}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},3351(e,n,o){o.d(n,{R:()=>i,x:()=>a});var t=o(2128);const r={},s=t.createContext(r);function i(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);
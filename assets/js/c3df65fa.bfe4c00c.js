"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[747],{3146(e,n,r){r.d(n,{R:()=>i,x:()=>l});var s=r(1299);const t={},o=s.createContext(t);function i(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(o.Provider,{value:n},e.children)}},6410(e,n,r){r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"packages/oxide","title":"@globalart/oxide","description":"Rust\'s Option and Result, implemented for TypeScript. Zero dependencies, full test coverage and complete in-editor documentation.","source":"@site/content/packages/oxide.mdx","sourceDirName":"packages","slug":"/packages/oxide","permalink":"/packages/oxide","draft":false,"unlisted":false,"editUrl":"https://github.com/GlobalArtInc/ecosystem/tree/main/docs/content/packages/oxide.mdx","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9},"sidebar":"tutorialSidebar","previous":{"title":"@globalart/passport","permalink":"/packages/passport"},"next":{"title":"@globalart/ddd","permalink":"/packages/ddd"}}');var t=r(6259),o=r(3146);const i={sidebar_position:9},l="@globalart/oxide",a={},c=[{value:"Installation",id:"installation",level:2},{value:"Overview",id:"overview",level:2},{value:"Key Features",id:"key-features",level:2},{value:"Quick Start",id:"quick-start",level:2},{value:"Importing",id:"importing",level:3},{value:"Option",id:"option",level:2},{value:"Result",id:"result",level:2},{value:"Converting",id:"converting",level:2},{value:"into",id:"into",level:3},{value:"intoTuple",id:"intotuple",level:3},{value:"from",id:"from",level:3},{value:"nonNull",id:"nonnull",level:3},{value:"qty",id:"qty",level:3},{value:"Nesting",id:"nesting",level:2},{value:"Iteration",id:"iteration",level:2},{value:"Safe",id:"safe",level:2},{value:"Safe Functions",id:"safe-functions",level:3},{value:"Safe Promises",id:"safe-promises",level:3},{value:"All",id:"all",level:2},{value:"Any",id:"any",level:2},{value:"Match",id:"match",level:2},{value:"Combined Match",id:"combined-match",level:2},{value:"Match Chains",id:"match-chains",level:2},{value:"Examples",id:"examples",level:3},{value:"Compiling",id:"compiling",level:2},{value:"Best Practices",id:"best-practices",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"globalartoxide",children:"@globalart/oxide"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://rust-lang.org",children:"Rust"}),"'s ",(0,t.jsx)(n.code,{children:"Option<T>"})," and ",(0,t.jsx)(n.code,{children:"Result<T, E>"}),", implemented for TypeScript. Zero dependencies, full test coverage and complete in-editor documentation."]}),"\n",(0,t.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",metastring:"npm2yarn",children:"npm install @globalart/oxide --save\n"})}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"@globalart/oxide"})," package brings Rust's powerful error handling and optional value patterns to TypeScript. It provides:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Option Type"})," - Represent values that may or may not exist"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Result Type"})," - Represent operations that may succeed or fail"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Pattern Matching"})," - Powerful match expressions for type-safe branching"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Zero Dependencies"})," - Lightweight and fast"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Full TypeScript Support"})," - Complete type safety and IntelliSense"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"key-features",children:"Key Features"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Type Safety"})," - Full TypeScript support with proper types"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Zero Dependencies"})," - No external dependencies"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Pattern Matching"})," - Powerful match expressions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Iteration Support"})," - Iterate over Option/Result values"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Safe Execution"})," - Safe function and Promise wrappers"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Combinators"})," - ",(0,t.jsx)(n.code,{children:"all"}),", ",(0,t.jsx)(n.code,{children:"any"}),", and other useful combinators"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"quick-start",children:"Quick Start"}),"\n",(0,t.jsx)(n.h3,{id:"importing",children:"Importing"}),"\n",(0,t.jsxs)(n.p,{children:["You can import the complete ",(0,t.jsx)(n.strong,{children:"@globalart/oxide"})," library:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import {\n  Option,\n  Some,\n  None,\n  Result,\n  Ok,\n  Err,\n  match,\n  Fn,\n  _,\n} from "@globalart/oxide";\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Or just the ",(0,t.jsx)(n.strong,{children:"core"})," library, which excludes the ",(0,t.jsx)(n.code,{children:"match"})," feature:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { Option, Some, None, Result, Ok, Err } from "@globalart/oxide/core";\n'})}),"\n",(0,t.jsx)(n.h2,{id:"option",children:"Option"}),"\n",(0,t.jsxs)(n.p,{children:["An Option represents either something, or nothing. If we hold a value of type ",(0,t.jsx)(n.code,{children:"Option<T>"}),", we know it is either ",(0,t.jsx)(n.code,{children:"Some<T>"})," or ",(0,t.jsx)(n.code,{children:"None"}),". Both types share a common API, so we can chain operations without having to worry whether we have Some or None until pulling the value out:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { Option, Some, None } from "@globalart/oxide";\n\nfunction divide(x: number, by: number): Option<number> {\n  return by === 0 ? None : Some(x / by);\n}\n\nconst val = divide(100, 20);\n\n// Pull the value out, or throw if None:\nconst res: number = val.unwrap();\n\n// Throw a custom error message in the case of None:\nconst res: number = val.expect("Don\'t divide by zero!");\n\n// Pull the value out, or use a default if None:\nconst res: number = val.unwrapOr(1);\n\n// Map the Option<T> to Option<U> by applying a function:\nconst strval: Option<string> = val.map((num) => `val = ${num}`);\n\n// Unwrap the value or use a default if None:\nconst res: string = strval.unwrapOr("val = <none>");\n\n// Map, assign a default and unwrap in one line:\nconst res: string = val.mapOr("val = <none>", (num) => `val = ${num}`);\n'})}),"\n",(0,t.jsx)(n.h2,{id:"result",children:"Result"}),"\n",(0,t.jsxs)(n.p,{children:["A Result represents either something good (",(0,t.jsx)(n.code,{children:"T"}),") or something not so good (",(0,t.jsx)(n.code,{children:"E"}),"). If we hold a value of type ",(0,t.jsx)(n.code,{children:"Result<T, E>"})," we know it's either ",(0,t.jsx)(n.code,{children:"Ok<T>"})," or ",(0,t.jsx)(n.code,{children:"Err<E>"}),". You could think of a Result as an Option where None has a value."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { Result, Ok, Err } from "@globalart/oxide";\n\nfunction divide(x: number, by: number): Result<number, string> {\n  return by === 0 ? Err("Division by zero") : Ok(x / by);\n}\n\nconst val = divide(100, 20);\n\n// These are the same as Option (as are many of the other methods):\nconst res: number = val.unwrap();\nconst res: number = val.expect("Don\'t divide by zero!");\nconst res: number = val.unwrapOr(1);\n\n// Map Result<T, E> to Result<U, E>\nconst strval: Result<string, string> = val.map((num) => `val = ${num}`);\nconst res: string = strval.unwrapOr("val = <err>");\nconst res: string = val.mapOr("val = <err>", (num) => `val = ${num}`);\n\n// Unwrap or expect the Err (throws if the Result is Ok):\nconst err: string = val.unwrapErr();\nconst err: string = val.expectErr("Expected division by zero!");\n\n// Or map the Err, converting Result<T, E> to Result<T, F>\nconst errobj: Result<string, Error> = val.mapErr((msg) => new Error(msg));\n'})}),"\n",(0,t.jsx)(n.h2,{id:"converting",children:"Converting"}),"\n",(0,t.jsxs)(n.p,{children:["These methods provide a way to jump in to (and out of) ",(0,t.jsx)(n.code,{children:"Option"})," and ",(0,t.jsx)(n.code,{children:"Result"})," types. Particularly these methods can streamline things where:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["A function returns ",(0,t.jsx)(n.code,{children:"T | null"}),", ",(0,t.jsx)(n.code,{children:"T | false"})," or similar."]}),"\n",(0,t.jsxs)(n.li,{children:["You are working with physical quantities or using an ",(0,t.jsx)(n.code,{children:"indexOf"})," method."]}),"\n",(0,t.jsxs)(n.li,{children:["A function accepts an optional argument, ",(0,t.jsx)(n.code,{children:"T | null"})," or similar."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note:"})," Converting to a Result often leaves you with a ",(0,t.jsx)(n.code,{children:"Result<T, null>"}),". The null value here is not very useful - consider the equivalent Option method to create an ",(0,t.jsx)(n.code,{children:"Option<T>"}),", or use ",(0,t.jsx)(n.code,{children:"mapErr"})," to change the ",(0,t.jsx)(n.code,{children:"E"})," type."]}),"\n",(0,t.jsx)(n.h3,{id:"into",children:"into"}),"\n",(0,t.jsxs)(n.p,{children:["Convert an existing ",(0,t.jsx)(n.code,{children:"Option"}),"/",(0,t.jsx)(n.code,{children:"Result"})," into a union type containing ",(0,t.jsx)(n.code,{children:"T"})," and ",(0,t.jsx)(n.code,{children:"undefined"})," (or a provided falsey value)."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"function maybeName(): Option<string>;\nfunction maybeNumbers(): Result<number[], Error>;\nfunction printOut(msg?: string): void;\n\nconst name: string | undefined = maybeName().into();\nconst name: string | null = maybeName().into(null);\n\n// Note that the into type does not reflect the E type:\nconst numbers: number[] | undefined = maybeNumbers().into();\nconst numbers: number[] | false = maybeNumbers().into(false);\n\n// As a function argument:\nprintOut(name.into());\n"})}),"\n",(0,t.jsx)(n.h3,{id:"intotuple",children:"intoTuple"}),"\n",(0,t.jsxs)(n.p,{children:["Convert a ",(0,t.jsx)(n.code,{children:"Result<T, E>"})," into a tuple of ",(0,t.jsx)(n.code,{children:"[null, T]"})," if the result is ",(0,t.jsx)(n.code,{children:"Ok"}),", or ",(0,t.jsx)(n.code,{children:"[E, null]"})," otherwise."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"function getUsername(): Result<string, Error>;\n\nconst query = getUsername();\nconst [err, res] = query.intoTuple();\n\nif (err) {\n  console.error(`Query Error: ${err}`);\n} else {\n  console.log(`Welcome: ${res.toLowerCase()}`);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"from",children:"from"}),"\n",(0,t.jsxs)(n.p,{children:["Convert to an ",(0,t.jsx)(n.code,{children:"Option"}),"/",(0,t.jsx)(n.code,{children:"Result"})," which is ",(0,t.jsx)(n.code,{children:"Some<T>"}),"/",(0,t.jsx)(n.code,{children:"Ok<T>"})," unless the value is falsey, an instance of ",(0,t.jsx)(n.code,{children:"Error"})," or an invalid ",(0,t.jsx)(n.code,{children:"Date"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"T"})," is narrowed to exclude any falsey values or Errors."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'const people = ["Fry", "Leela", "Bender"];\n\n// Create an Option<string> from a find:\nconst person = Option.from(people.find((name) => name === "Fry"));\n\n// or shorter:\nconst person = Option(people.find((name) => name === "Bender"));\n'})}),"\n",(0,t.jsxs)(n.p,{children:["In the case of ",(0,t.jsx)(n.code,{children:"Result"}),", the ",(0,t.jsx)(n.code,{children:"E"})," type includes:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"null"})," (if ",(0,t.jsx)(n.code,{children:"val"})," could have been falsey or an invalid date)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Error"})," types excluded from ",(0,t.jsx)(n.code,{children:"T"})," (if there are any)"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"function randomName(): string | false;\nfunction tryName(): string | Error;\nfunction randomNumbers(): number[] | Error;\n\n// Create a Result<string, null>\nconst person = Result.from(randomName());\n\n// Create a Result<string, Error | null>\nconst name = Result(tryName());\n\n// Create a Result<number[], Error>\nconst num = Result(randomNumbers());\n"})}),"\n",(0,t.jsx)(n.h3,{id:"nonnull",children:"nonNull"}),"\n",(0,t.jsxs)(n.p,{children:["Convert to an ",(0,t.jsx)(n.code,{children:"Option"}),"/",(0,t.jsx)(n.code,{children:"Result"})," which is ",(0,t.jsx)(n.code,{children:"Some<T>"}),"/",(0,t.jsx)(n.code,{children:"Ok<T>"})," unless the value provided is ",(0,t.jsx)(n.code,{children:"undefined"}),", ",(0,t.jsx)(n.code,{children:"null"})," or ",(0,t.jsx)(n.code,{children:"NaN"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'function getNum(): number | null;\nconst num = Option.nonNull(getNum()).unwrapOr(100); // Could be 0\n\nconst words = ["express", "", "planet"];\nconst str = Option.nonNull(words[getNum()]);\nstr.unwrapOr("No such index"); // Could be ""\n'})}),"\n",(0,t.jsx)(n.h3,{id:"qty",children:"qty"}),"\n",(0,t.jsxs)(n.p,{children:["Convert to an ",(0,t.jsx)(n.code,{children:"Option"}),"/",(0,t.jsx)(n.code,{children:"Result"})," which is ",(0,t.jsx)(n.code,{children:"Some<number>"}),"/",(0,t.jsx)(n.code,{children:"Ok<number>"})," when the provided ",(0,t.jsx)(n.code,{children:"val"})," is a finite integer greater than or equal to 0."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'const word = "Buggalo";\n\nconst g = Option.qty(word.indexOf("g"));\nassert.equal(g.unwrap(), 2);\n\nconst z = Option.qty(word.indexOf("z"));\nassert.equal(z.isNone(), true);\n'})}),"\n",(0,t.jsx)(n.h2,{id:"nesting",children:"Nesting"}),"\n",(0,t.jsxs)(n.p,{children:["You can nest ",(0,t.jsx)(n.code,{children:"Option"})," and ",(0,t.jsx)(n.code,{children:"Result"})," structures. The following example uses nesting to distinguish between ",(0,t.jsx)(n.em,{children:"found something"}),", ",(0,t.jsx)(n.em,{children:"found nothing"})," and ",(0,t.jsx)(n.em,{children:"database error"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'function search(query: string): Result<Option<SearchResult>, string> {\n  const [err, result] = database.search(query);\n  if (err) {\n    return Err(err);\n  } else {\n    return Ok(result.count > 0 ? Some(result) : None);\n  }\n}\n\nconst result = search("testing");\nconst output: string = match(result, {\n  Ok: {\n    Some: (result) => `Found ${result.count} entries.`,\n    None: () => "No results for that search.",\n  },\n  Err: (err) => `Error: ${err}.`,\n});\n'})}),"\n",(0,t.jsx)(n.h2,{id:"iteration",children:"Iteration"}),"\n",(0,t.jsxs)(n.p,{children:["An ",(0,t.jsx)(n.code,{children:"Option"})," or ",(0,t.jsx)(n.code,{children:"Result"})," that contains an iterable ",(0,t.jsx)(n.code,{children:"T"})," type can be iterated upon directly. In the case of ",(0,t.jsx)(n.code,{children:"None"})," or ",(0,t.jsx)(n.code,{children:"Err"}),", an empty iterator is returned."]}),"\n",(0,t.jsxs)(n.p,{children:["The compiler will complain if the inner type is not definitely iterable (including ",(0,t.jsx)(n.code,{children:"any"}),"), or if the monad is known to be ",(0,t.jsx)(n.code,{children:"None"})," or ",(0,t.jsx)(n.code,{children:"Err"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'const numbers = Option([1.12, 2.23, 3.34]);\nfor (const num of numbers) {\n  console.log("Number is:", num.toFixed(1));\n}\n\nconst numbers: Option<number[]> = None;\nfor (const num of numbers) {\n  console.log("Unreachable:", num.toFixed());\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"It's also possible to iterate over nested monads in the same way:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'const numbers = Option(Result(Option([1, 2, 3])));\nfor (const num of numbers) {\n  console.log("Number is:", num.toFixed(1));\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"safe",children:"Safe"}),"\n",(0,t.jsxs)(n.p,{children:["Capture the outcome of a function or Promise as an ",(0,t.jsx)(n.code,{children:"Option<T>"})," or ",(0,t.jsx)(n.code,{children:"Result<T, E>"}),", preventing throwing (function) or rejection (Promise)."]}),"\n",(0,t.jsx)(n.h3,{id:"safe-functions",children:"Safe Functions"}),"\n",(0,t.jsxs)(n.p,{children:["Calls the passed function with the arguments provided and returns an ",(0,t.jsx)(n.code,{children:"Option<T>"})," or ",(0,t.jsx)(n.code,{children:"Result<T, Error>"}),". The outcome is ",(0,t.jsx)(n.code,{children:"Some"}),"/",(0,t.jsx)(n.code,{children:"Ok"})," if the function returned, or ",(0,t.jsx)(n.code,{children:"None"}),"/",(0,t.jsx)(n.code,{children:"Err"})," if it threw. In the case of ",(0,t.jsx)(n.code,{children:"Result.safe"}),", any thrown value which is not an ",(0,t.jsx)(n.code,{children:"Error"})," is converted."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'function mightThrow(throws: boolean) {\n  if (throws) {\n    throw new Error("Throw");\n  }\n  return "Hello World";\n}\n\nconst x: Result<string, Error> = Result.safe(mightThrow, true);\nassert.equal(x.unwrapErr() instanceof Error, true);\nassert.equal(x.unwrapErr().message, "Throw");\n\nconst x = Result.safe(() => mightThrow(false));\nassert.equal(x.unwrap(), "Hello World");\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note:"})," Any function which returns a Promise (or PromiseLike) value is rejected by the type signature. ",(0,t.jsx)(n.code,{children:"Result<Promise<T>, Error>"})," or ",(0,t.jsx)(n.code,{children:"Option<Promise<T>>"})," are not useful types - using it in this way is likely to be a mistake."]}),"\n",(0,t.jsx)(n.h3,{id:"safe-promises",children:"Safe Promises"}),"\n",(0,t.jsxs)(n.p,{children:["Accepts a ",(0,t.jsx)(n.code,{children:"Promise"})," and returns a new Promise which always resolves to either an ",(0,t.jsx)(n.code,{children:"Option<T>"})," or ",(0,t.jsx)(n.code,{children:"Result<T, Error>"}),". The Result is ",(0,t.jsx)(n.code,{children:"Some"}),"/",(0,t.jsx)(n.code,{children:"Ok"})," if the original promise resolved, or ",(0,t.jsx)(n.code,{children:"None"}),"/",(0,t.jsx)(n.code,{children:"Err"})," if it rejected. In the case of ",(0,t.jsx)(n.code,{children:"Result.safe"}),", any rejection value which is not an ",(0,t.jsx)(n.code,{children:"Error"})," is converted."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'async function mightThrow(throws: boolean) {\n  if (throws) {\n    throw new Error("Throw");\n  }\n  return "Hello World";\n}\n\nconst x = await Result.safe(mightThrow(true));\nassert.equal(x.unwrapErr() instanceof Error, true);\nassert.equal(x.unwrapErr().message, "Throw");\n\nconst x = await Result.safe(mightThrow(false));\nassert.equal(x.unwrap(), "Hello World");\n'})}),"\n",(0,t.jsx)(n.h2,{id:"all",children:"All"}),"\n",(0,t.jsxs)(n.p,{children:["Reduce multiple ",(0,t.jsx)(n.code,{children:"Option"}),"s or ",(0,t.jsx)(n.code,{children:"Result"}),"s to a single one. The first ",(0,t.jsx)(n.code,{children:"None"})," or ",(0,t.jsx)(n.code,{children:"Err"})," encountered is returned, otherwise the outcome is a ",(0,t.jsx)(n.code,{children:"Some"}),"/",(0,t.jsx)(n.code,{children:"Ok"})," containing an array of all the unwrapped values."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'function num(val: number): Result<number, string> {\n  return val > 10 ? Ok(val) : Err(`Value ${val} is too low.`);\n}\n\nconst xyz = Result.all(num(20), num(30), num(40));\nconst [x, y, z] = xyz.unwrap();\nassert.equal(x, 20);\nassert.equal(y, 30);\nassert.equal(z, 40);\n\nconst err = Result.all(num(20), num(5), num(40));\nassert.equal(err.isErr(), true);\nassert.equal(err.unwrapErr(), "Value 5 is too low.");\n'})}),"\n",(0,t.jsx)(n.h2,{id:"any",children:"Any"}),"\n",(0,t.jsxs)(n.p,{children:["Reduce multiple ",(0,t.jsx)(n.code,{children:"Option"}),"s or ",(0,t.jsx)(n.code,{children:"Result"}),"s into a single one. The first ",(0,t.jsx)(n.code,{children:"Some"}),"/",(0,t.jsx)(n.code,{children:"Ok"})," found (if any) is returned, otherwise the outcome is ",(0,t.jsx)(n.code,{children:"None"}),", or in the case of ",(0,t.jsx)(n.code,{children:"Result"})," - an ",(0,t.jsx)(n.code,{children:"Err"})," containing an array of all the unwrapped errors."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'function num(val: number): Result<number, string> {\n  return val > 10 ? Ok(val) : Err(`Value ${val} is too low.`);\n}\n\nconst x = Result.any(num(5), num(20), num(2));\nassert.equal(x.unwrap(), 20);\n\nconst efg = Result.any(num(2), num(5), num(8));\nconst [e, f, g] = efg.unwrapErr();\nassert.equal(e, "Value 2 is too low.");\nassert.equal(f, "Value 5 is too low.");\nassert.equal(g, "Value 8 is too low.");\n'})}),"\n",(0,t.jsx)(n.h2,{id:"match",children:"Match"}),"\n",(0,t.jsxs)(n.p,{children:["Mapped matching is possible on ",(0,t.jsx)(n.code,{children:"Option"})," and ",(0,t.jsx)(n.code,{children:"Result"})," types:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const num = Option(10);\nconst res = match(num, {\n  Some: (n) => n + 1,\n  None: () => 0,\n});\n\nassert.equal(res, 11);\n"})}),"\n",(0,t.jsx)(n.p,{children:"You can nest mapped matching patterns and provide defaults. If a default is not found in the current level it will fall back to the previous level. When no suitable match or default is found, an exhausted error is thrown."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'function nested(val: Result<Option<number>, string>): string {\n  return match(val, {\n    Ok: { Some: (num) => `found ${num}` },\n    _: () => "nothing",\n  });\n}\n\nassert.equal(nested(Ok(Some(10))), "found 10");\nassert.equal(nested(Ok(None)), "nothing");\nassert.equal(nested(Err("Not a number")), "nothing");\n'})}),"\n",(0,t.jsx)(n.h2,{id:"combined-match",children:"Combined Match"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"#match",children:"Mapped"})," Matching and ",(0,t.jsx)(n.a,{href:"#match-chains",children:"Chained"})," Matching can be combined. A match chain can be provided instead of a function for ",(0,t.jsx)(n.code,{children:"Some"}),", ",(0,t.jsx)(n.code,{children:"Ok"})," and ",(0,t.jsx)(n.code,{children:"Err"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'function matchNum(val: Option<number>): string {\n  return match(val, {\n    Some: [\n      [5, "5"],\n      [(x) => x < 10, "< 10"],\n      [(x) => x > 20, "> 20"],\n    ],\n    _: () => "none or not matched",\n  });\n}\n\nassert.equal(matchNum(Some(5)), "5");\nassert.equal(matchNum(Some(7)), "< 10");\nassert.equal(matchNum(Some(25)), "> 20");\nassert.equal(matchNum(Some(15)), "none or not matched");\nassert.equal(matchNum(None), "none or not matched");\n'})}),"\n",(0,t.jsx)(n.h2,{id:"match-chains",children:"Match Chains"}),"\n",(0,t.jsxs)(n.p,{children:["Chained matching is possible on any type. Branches are formed by associating a ",(0,t.jsx)(n.code,{children:"condition"})," with a ",(0,t.jsx)(n.code,{children:"result"})," (with an optional default at the end). The first matching branch is the result."]}),"\n",(0,t.jsx)(n.p,{children:"More detail about chained matching patterns is available in the bundled JSDoc."}),"\n",(0,t.jsx)(n.h3,{id:"examples",children:"Examples"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'function matchArr(arr: number[]): string {\n  return match(arr, [\n    [[1], "1"],\n    [[2, (x) => x > 10], "2, > 10"],\n    [[_, 6, 9, _], (a) => a.join(", ")],\n    () => "other",\n  ]);\n}\n\nassert.equal(matchArr([1, 2, 3]), "1");\nassert.equal(matchArr([2, 12, 6]), "2, > 10");\nassert.equal(matchArr([3, 6, 9]), "other");\nassert.equal(matchArr([3, 6, 9, 12]), "3, 6, 9, 12");\nassert.equal(matchArr([2, 4, 6]), "other");\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'interface ExampleObj {\n  a: number;\n  b?: { c: number };\n  o?: number;\n}\n\nfunction matchObj(obj: ExampleObj): string {\n  return match(obj, [\n    [{ a: 5 }, "a = 5"],\n    [{ b: { c: 5 } }, "c = 5"],\n    [{ a: 10, o: _ }, "a = 10, o = _"],\n    [{ a: 15, b: { c: (n) => n > 10 } }, "a = 15; c > 10"],\n    () => "other",\n  ]);\n}\n\nassert.equal(matchObj({ a: 5 }), "a = 5");\nassert.equal(matchObj({ a: 50, b: { c: 5 } }), "c = 5");\nassert.equal(matchObj({ a: 10 }), "other");\nassert.equal(matchObj({ a: 10, o: 1 }), "a = 10, o = _");\nassert.equal(matchObj({ a: 15, b: { c: 20 } }), "a = 15; c > 10");\nassert.equal(matchObj({ a: 8, b: { c: 8 }, o: 1 }), "other");\n'})}),"\n",(0,t.jsx)(n.h2,{id:"compiling",children:"Compiling"}),"\n",(0,t.jsxs)(n.p,{children:["Match patterns can also be ",(0,t.jsx)(n.em,{children:"compiled"})," into a function. More detail about compiling is available in the bundled JSDoc."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'const matchSome = match.compile({\n  Some: (n: number) => `some ${n}`,\n  None: () => "none",\n});\n\nassert.equal(matchSome(Some(1)), "some 1");\nassert.equal(matchSome(None), "none");\n'})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use Option for nullable values"})," - Replace ",(0,t.jsx)(n.code,{children:"T | null"})," or ",(0,t.jsx)(n.code,{children:"T | undefined"})," with ",(0,t.jsx)(n.code,{children:"Option<T>"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use Result for error handling"})," - Replace throwing functions with ",(0,t.jsx)(n.code,{children:"Result<T, E>"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Chain operations"})," - Use ",(0,t.jsx)(n.code,{children:"map"}),", ",(0,t.jsx)(n.code,{children:"andThen"}),", and other combinators for clean code"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Pattern matching"})," - Use ",(0,t.jsx)(n.code,{children:"match"})," for exhaustive pattern matching"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Safe execution"})," - Use ",(0,t.jsx)(n.code,{children:"safe"})," wrappers for functions and Promises that might throw"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Combine results"})," - Use ",(0,t.jsx)(n.code,{children:"all"})," and ",(0,t.jsx)(n.code,{children:"any"})," for combining multiple results"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);
import type { ZodTypeAny } from "zod";
import type { ZodToProtobufOptions } from "./types";
import { traverseSchema } from "./traversers";
import { generateServices } from "./service-generator";
import { z } from "zod";

/**
 * Converts a Zod schema to a protobuf definition string.
 * Generates messages, enums, and services based on the provided schema and options.
 *
 * @param schema - Optional Zod schema to convert (if not provided, only services will be generated)
 * @param options - Options for protobuf generation including package name, root message name, type prefix, and services
 * @returns Complete protobuf definition string
 */
export const zodToProtobufService = (
  options: ZodToProtobufOptions = {},
): string => {
  const {
    packageName = "default",
    typePrefix = "",
    services,
  } = options;

  const messages = new Map<string, string[]>();
  const enums = new Map<string, string[]>();

  const context = {
    messages,
    enums,
    typePrefix: typePrefix || null,
  };

  const hasServices =
    services &&
    (Array.isArray(services)
      ? services.length > 0
      : Object.keys(services).length > 0);

  const servicesString = hasServices ? generateServices(services, context) : [];

  const enumsString = Array.from(enums.values()).map((enumDef) =>
    enumDef.join("\n"),
  );

  const messagesString = Array.from(messages.entries()).map(
    ([name, fields]) =>
      `message ${name} {\n${fields.map((field) => `    ${field}`).join("\n")}\n}`,
  );

  const content = [servicesString, enumsString, messagesString]
    .filter((strings) => !!strings.length)
    .map((strings) => strings.join("\n\n"))
    .join("\n\n");

  let protoDefinition: string = "";
  if (options.warningDeclaration !== false) {
    protoDefinition += `
/**
 * This file was automatically generated by zod-to-proto.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source Zod schema.
 */
`;
  }

  protoDefinition += `
syntax = "proto3";
package ${packageName};

${content}
`;

  return protoDefinition.trim();
};
